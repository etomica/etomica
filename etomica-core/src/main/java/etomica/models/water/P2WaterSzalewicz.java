/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

package etomica.models.water;

import etomica.atom.AtomPair;
import etomica.atom.IAtomList;
import etomica.atom.IAtomOriented;
import etomica.box.Box;
import etomica.chem.elements.ElementSimple;
import etomica.chem.elements.Hydrogen;
import etomica.chem.elements.Oxygen;
import etomica.potential.IPotentialAtomic;
import etomica.potential.IPotentialTorque;
import etomica.simulation.Simulation;
import etomica.space.IOrientation;
import etomica.space.Space;
import etomica.space.Tensor;
import etomica.space.Vector;
import etomica.space3d.IOrientation3D;
import etomica.space3d.OrientationFull3D;
import etomica.space3d.Space3D;
import etomica.space3d.Vector3D;
import etomica.species.SpeciesGeneral;
import etomica.species.SpeciesSpheresRotating;
import etomica.units.*;
import etomica.util.Constants;
import etomica.util.random.RandomMersenneTwister;
import etomica.util.random.RandomNumberGeneratorUnix;

import java.util.Arrays;

/**
 * Water potential as described by
 * 
 * http://dx.doi.org/10.1063/1.4875097
 * 
 * This class handles 2-body, 3-body and induction terms.
 * The behavior can be set to compute all(ALL), induction only (INDUCTION),
 * only 2-body (TWO_BODY) or only non-additive (NON_PAIR) via the
 * setComponent() method.
 */
public class P2WaterSzalewicz implements IPotentialTorque {
    public static final boolean broken3body = false;
    
    protected static final double[][] siteDoubles= new double[][]{
        { 0.00000000000000, 0.0000000, 0.1255334885}, //! O     x    x     x
        {-1.45365196228170, 0.0000000,-0.9961538357}, //! H     x    x     x
        { 1.45365196228170, 0.0000000,-0.9961538357}, //! H     x    x     x
        { 0.00000000000000,-0.2067213,-0.2462589474}, //! D1         x
        { 0.00000000000000, 0.2067213,-0.2462589474}, //! D1         x
        { 0.90,  0.053,  0.64}, //! N1
        {-0.90,  0.053,  0.64}, //! N1
        { 0.90, -0.053,  0.64}, //! N1
        {-0.90, -0.053,  0.64}, //! N1
        { 1.29,  0.14,  -0.91}, //! N2
        {-1.29,  0.14,  -0.91}, //! N2
        { 1.29, -0.14,  -0.91}, //! N2
        {-1.29, -0.14,  -0.91}, //! N2
        { 0.56,  0.24,  -0.48}, //! N3
        {-0.56,  0.24,  -0.48}, //! N3
        { 0.56, -0.24,  -0.48}, //! N3
        {-0.56, -0.24,  -0.48}, //! N3
        { 0.91,  0.21,  -0.68}, //! N4
        {-0.91,  0.21,  -0.68}, //! N4
        { 0.91, -0.21,  -0.68}, //! N4
        {-0.91, -0.21,  -0.68}, //! N4
        { 1.48,  0.26,  -0.62}, //! N5
        {-1.48,  0.26,  -0.62}, //! N5
        { 1.48, -0.26,  -0.62}, //! N5
        {-1.48, -0.26,  -0.62} };  //   ! N5
    protected final static double mass, cmzFix;
    protected static final Vector[] sites;

    static {
        mass = Oxygen.INSTANCE.getMass() + 2 * Hydrogen.INSTANCE.getMass();
        // why not put the center of mass at 0?
        cmzFix = Oxygen.INSTANCE.getMass() * siteDoubles[0][2] + 2 * Hydrogen.INSTANCE.getMass() * siteDoubles[1][2];

        sites = new Vector[siteDoubles.length];
        for (int i=0; i<sites.length; i++) {
            siteDoubles[i][2] -= cmzFix;
            sites[i] = Vector.of(siteDoubles[i]);
        }
    }

    protected static final double[] params = new double[]{0, 0, 0.1255334885, -1.4536519622817, 0, -0.9961538357, 1.4536519622817,
        0, -0.9961538357, 0, -0.2, 0.2509015636, 0, 0.2, 0.2509015636, 0, 0, 0.901563600000000E-03, 0,
        -0.2067213, -0.2462589474, 0, 0.2067213, -0.2462589474, 0.292574106, 0.560656704, -0.706943757, 
        1.35345089381329, 2.14313877133876, 3.04092874317157, 0.622194727946389, 1.06708304741226, 
        3.49829936232352, 1.3833246009007, 1.82580079225269, 1.82873545312534, 2.09653769062008, 
        1.78241663625156, 2.09215758469466, 2.10314177506165, 1.66200346451383, 2.10218589044614, 
        2.0987332629015, 798.954416033091, 0.159572026651432E-02, 3.07255638214593, 0.303376733122468E-02, 
        0.159879548255406E-02, 147.954218709382, 2590.12623494292, 2.87526922362781, 44.574970095394, 
        0.505118050257011E-01, 80297.8496437032, 64.1544374518401, -1.28214452150474, -19853.5308599894, 
        -16.4603037820018, 4688.34352869783, -44640.9050010239, -24.4936426944537, 10418.2412079926, 
        21159.8246015963, -56312.5987515841, -27.1813613063599, 0.246991139598603, 13964.915240729, 
        7.70425238770347, -3388.4756002758, 30003.8612947627, 7.89038376784594, -7280.41770715155, 
        -14592.3987914364, 11056.3353469311, 9.95207801783226, -0.106475443654262E-03, -2731.12968796633, 
        -2.81816996753887, 665.193931689996, -5898.9139388964, -3.49870762894619, 1443.72831135503, 
        2956.12938418041, -5.99065787079302, 11.0853319739237, 2.18305747697925, 5673.00076940336, 
        -976.255515504995, -114.47510639294, -221376.904168841, 45098.1155886089, 3419.59023852565, 0.01,
        1.77101727760606, 0.487927064879705, 1.36094920804492, 0.100000000000000E-02, 0.763254536636233, 
        1.37545304940238, 0.571428305917218, 1.7502618994729, 1.09674762779597, 0.800518240697506, 
        1.78357984550909, 2.21817576928891, 1.05654732514568, 2.3639195247895, 1.5088438641977, 
        1.4836870728486, 1.09047747155958, 0.976438649550801, 1.22850484274125, 1.1002898984108, 
        1.65353120651391, 2.46069053277997, 1.52749427946021, 1.20350655125187, 1.58050272962452, 
        1.46552776390808, 1.06901915456608, 1.23529742028517, 1.09498393978636, 1.34590863750053, 
        1.15922843670473, 1.3251986446695, 1.47655234931328, 1.34793438673587, 2.38307180278784, 
        1.97259120886505, 1.17896619624013, 1.96104694340102, 1.75669785792568, 1.59888350106323, 1.49777775097233};
    protected static final double[] c = new double[]{-3.15026658247066, 9.86203882055045, -2.00097054237398, 56.8391559299755,
        0.163138977386684, -8.22593964000838, 207.45802209931, -18.3598397933055, -0.856041979388345,
        6.23115697982204, 11.1317012110773, -126.931403554699, -0.99680921614099, 21.8054627027364, 
        79.7830880715, -0.134232277097764E-01, 1.30949575899661, 1.14492673120874, -7.12524714063864, 
        -11.5742822262846, -42.1416351281405, 18.5722394301885, -10.1023485207421, -49.1684262135191, 
        -0.286832384552035, 11.4503097088275, 28.2692445936052, -23.9348394500569, 0.306955392253812, 
        0.870648973096436, -2.29276447233711, -0.637024706566269E-02, -0.787912499632397, 0.264585493796953E-01,
        0.301293903779294, 0.455022973596551E-02, 3.37396994191073, 7.05428601707747, -8.90593581844556, 
        -24.3886017631604, -0.196253304364951, -8.82848067918362, -294.396109098229, -4.75538332455826, 
        1.62473844629561, 3.62125598653775, 14.4001210073539, 72.2891526609781, 0.315813038354126, 
        4.81568916697987, -35.0235301545436, 0.566166901871597E-01, -1.91495958955011, -0.327464652157014, 
        -2.45004325502204, -16.945762718898, -15.3133212870689, 2.08337812434001, -6.44696053142878, 
        12.7270533274531, -0.413664961488871, 6.04539313943101, 11.8565316682502, -10.925067528086, 
        -0.29555378281053, -0.83782649199419, 2.6196771218189, 0.952086522237373E-02, 0.941235335502593, 
        -0.214255898515057, -0.232511065352956, -0.222697578680639E-01, -2.31568666006022, 2.19598769099524, 
        2.54987803739554, 5.35229039014314, 0.460848275832722E-01, -2.33944808138098, 95.0293379912913, 
        0.511435128067617, -1.28677750123108, -0.572638414649863, 0.176929715192867, -19.4394495469832, 
        0.455832031227676E-01, 0.662013421276589, 8.92654329443285, -0.174775932727848E-01, 1.5652058370518, 
        0.225423258152985, 1.17481660505271, -0.413306457099163, 3.24137708973507, -2.12486889723323, 
        2.09697432837061, -3.30004766118075, 0.227240637939449, -2.80052613748771, -3.05598224093565, 
        -1.19676519588852, 0.800106357717622E-01, 0.466216060706309, -0.666563243728302, -0.679880700915619E-02,
        -0.500826289226449, -0.506942133519623E-01, 0.137846839681917, 0.124539685427480E-01, 0.101263130340127, 
        1.43602266371004, -0.678771858680276, -0.578978478965704, -0.153189704256810E-02, -1.00153475388584, 
        -22.7725241827249, -0.10928206229517, 0.318857121215428, 0.922350871883223E-01, 0.245767387950591E-01, 
        2.10895048362396, -0.148414561438362E-01, 0.176546659794428, -0.825232309409231, 0.774644916218678E-02,
        -0.253538382301681, -0.113765117914226, -0.175352575749319, -0.249826182290814, -0.850289246588856, 
        0.292897660885283, -0.101091167394478E-01, 0.19403494606947, -0.664803873871365E-02, 0.237038650285262, 
        0.275494902908078, 0.977060613307748, 0.126251563454678E-01, 0.294407794765073E-01, 0.604504528397771E-01, 
        0.692949159744035E-03, 0.747819064342587E-01, 0.331138626546516E-01, -0.386968365672333E-01, -0.208588284062886E-02};
    
    protected static final int[] ind_charge = new int[]{24,25,25,26,26};
    
    protected static final int[][] ind_beta = new int[][]{
    {   34, 35, 35,102,102,103,103,103,103,104,104,104,104,105,105,105,105,120,120,120,120,127,127,127,127}, // O
    {   35, 36, 36,106,106,107,107,107,107,108,108,108,108,109,109,109,109,121,121,121,121,128,128,128,128}, // H
    {   35, 36, 36,106,106,107,107,107,107,108,108,108,108,109,109,109,109,121,121,121,121,128,128,128,128}, // H
    {  102,106,106,110,110,111,111,111,111,112,112,112,112,113,113,113,113,122,122,122,122,129,129,129,129}, // D1
    {  102,106,106,110,110,111,111,111,111,112,112,112,112,113,113,113,113,122,122,122,122,129,129,129,129}, // D1
    {  103,107,107,111,111,114,114,114,114,115,115,115,115,116,116,116,116,123,123,123,123,130,130,130,130}, // N1
    {  103,107,107,111,111,114,114,114,114,115,115,115,115,116,116,116,116,123,123,123,123,130,130,130,130}, // N1
    {  103,107,107,111,111,114,114,114,114,115,115,115,115,116,116,116,116,123,123,123,123,130,130,130,130}, // N1
    {  103,107,107,111,111,114,114,114,114,115,115,115,115,116,116,116,116,123,123,123,123,130,130,130,130}, // N1
    {  104,108,108,112,112,115,115,115,115,117,117,117,117,118,118,118,118,124,124,124,124,131,131,131,131}, // N2
    {  104,108,108,112,112,115,115,115,115,117,117,117,117,118,118,118,118,124,124,124,124,131,131,131,131}, // N2
    {  104,108,108,112,112,115,115,115,115,117,117,117,117,118,118,118,118,124,124,124,124,131,131,131,131}, // N2
    {  104,108,108,112,112,115,115,115,115,117,117,117,117,118,118,118,118,124,124,124,124,131,131,131,131}, // N2
    {  105,109,109,113,113,116,116,116,116,118,118,118,118,119,119,119,119,125,125,125,125,132,132,132,132}, // N3
    {  105,109,109,113,113,116,116,116,116,118,118,118,118,119,119,119,119,125,125,125,125,132,132,132,132}, // N3
    {  105,109,109,113,113,116,116,116,116,118,118,118,118,119,119,119,119,125,125,125,125,132,132,132,132}, // N3
    {  105,109,109,113,113,116,116,116,116,118,118,118,118,119,119,119,119,125,125,125,125,132,132,132,132}, // N3
    {  120,121,121,122,122,123,123,123,123,124,124,124,124,125,125,125,125,126,126,126,126,133,133,133,133}, // N4
    {  120,121,121,122,122,123,123,123,123,124,124,124,124,125,125,125,125,126,126,126,126,133,133,133,133}, // N4
    {  120,121,121,122,122,123,123,123,123,124,124,124,124,125,125,125,125,126,126,126,126,133,133,133,133}, // N4
    {  120,121,121,122,122,123,123,123,123,124,124,124,124,125,125,125,125,126,126,126,126,133,133,133,133}, // N4
    {  127,128,128,129,129,130,130,130,130,131,131,131,131,132,132,132,132,133,133,133,133,134,134,134,134}, // N5
    {  127,128,128,129,129,130,130,130,130,131,131,131,131,132,132,132,132,133,133,133,133,134,134,134,134}, // N5
    {  127,128,128,129,129,130,130,130,130,131,131,131,131,132,132,132,132,133,133,133,133,134,134,134,134}, // N5
    {  127,128,128,129,129,130,130,130,130,131,131,131,131,132,132,132,132,133,133,133,133,134,134,134,134}  // N5
    };

    protected static final double[] params3 = new double[]{0.367911875041000,1.47433176636696,1.20347408390928,0.300000000000000E-01,1.00000000000000,1.08715694978386,-47909236.4512617,28607039.7051238,12558728.0435811,6282255.92169189,329466.621355586,130639.488489313,123.647622808153,-151.568453273019,-410.581367324416,-75.8689917755639,0.692599844971185,0.692599844971185,0.692599844971185,0.692599844971185,0.692599844971185,0.692599844971185,0.692599844971185,0.692599844971185,0.692599844971185,0.692599844971185,0.488877655105790,0.488877655105790,0.488877655105790,0.488877655105790,0.488877655105790,0.488877655105790,0.488877655105790,0.488877655105790,0.488877655105790,0.488877655105790,0.693231401521011,0.693231401521011,0.693231401521011,0.429183032897225,0.429183032897225,0.429183032897225,0.400000000000000,1.00000000000000,0.193727247280402,0.937416692042935,1.02677019603146,0.154679098366888,0.615780445242961E-01,0.597576243254318E-01,0.759247425267316,0.369813924868233E-01,1.06332588829546,0.120508170883445,0.223670576847358,1.04178614676572,1.08542576237527,0.179953187360260,0.242715569032482,1.01408409884587,0.613962012789749E-01,0.366821179682108E-01,1.96150567820753,1.05750595720992,1.43499703006369,14.7810587462011,10.2852347224659,15.0303889568659,17.4439529215033,1.00000000000000,2.78563635135636,20.0000000000000,1.51938882399474,19.1141927073032,5.65935909404222,1.06816270748274,1.13174312529828,1.00000000000000,20.0000357774967,1.41215698591240,15.9716317924453,1.22005094713053,19.2208111123355,0.999832907905987,1.16327054649064,9.20297145468226,0.335710316896439,0.374231477874771E-01,0.446179888248444,0.166657161725211,0.927842628406468,1.33772389606888,0.00000000000000,0.359848495666698,-0.114101433045152E-18,1.50170559503731,1.10561732135761,1.64806919562203,2.22917970471013,1.74585404944708,1.53928609790430,-0.115895879618482E-06,1.06717392367801,0.137614982715284,4.00000000000000,2.24039813631505,0.578065146353069E-01};
    protected static final double[] c3 = new double[]{-8.65140347978388,0.580430455725452,-0.751943474622773E-01,-0.880821334216731E-02,-83.5499639042617,27.9127007387234,42.1676303481709,-9.13365006843944,-16.6300277477151,2.65524060634113,-178.182859732951,374.376424957619,-77.1713265473569,-72.6785175827490,57.4169664932808,15.4208805006551,0.529790619894594,-0.690835744726803E-02,-0.309343913288925E-01,0.283675578635962E-02,0.156741387253804E-02,0.909666052702755E-03,1.35788251708420,-0.806197301466610E-01,-0.124294567888346,0.681898915216435E-02,0.287866007403678E-01,0.235075460497218E-02,-1414.49885468584,177.612598404164,360.239495189762,-46.2204509566919,-111.254811341964,15.0474502963690,51.2300510432964,-12.5712578642064,4.14301186772201,-16.5130286168093,4.61467448495361,-1.58277850829300,115.622435119819,2.17325635269409,-64.8196771919821,13.7390143506124,-24.4712543147251,1.72212740754969,12.0809650353800,-2.55489136051145,0.564063434677706,-0.774353530585289,-0.591791722384418,0.222020712553441,-0.629507744367009,0.346033539241991,0.129393503883174,-0.305196100348371E-01,-1.03222448274618,6.85708771863677,0.448104199459096,-1.31610955751068,-3.74697402883939,-0.239552958967996,0.438803133234344,0.277072235713105,-118.538546792825,25.2823299473209,42.7811353872578,-13.0349478239795,32.1397168527195,-8.32526048487885,-10.2365348783113,3.08609311069335,557.363881039663,-32.9775068147635,-21.3136312462178,94.8216706558509,-38.3382437726535,13.3119332607518,289.114637830581,-87.0102221366031,-77.7257115548440,21.7476244904583,-80.5103537118517,24.1771232961237,20.4039325898613,-6.01753900969061,271.271639442549,-82.4865752788851,-30.6481275773525,11.9698415941914,-102.039266920406,24.5281485006309,19.8264258605370,-5.91449925663880,-24.6496205639897,8.55055843115418,-39.2045589389396,10.7147491272348,-50.4717522507399,11.8807523726707,19.4105518577916,-4.81623722670497,-0.250070678015611E-01,-0.859013390861251E-03,0.319436164735881E-03,0.322207470065344E-03,0.105661106761949E-03,-0.137427812535246E-03,-0.103442416949821,0.778028023166309E-02,0.719671165848612E-02,-0.998209235817171E-03,0.987529754199506E-02,-0.288628052953951E-03,-0.218622000646905E-02,-0.863191607957889E-04,392.548476044972,51.3295623921004,73.7324536063838,-64.3816951714038,84.3622141416784,-34.3014081380932,5.14414546748345,12.1974714789506,-0.153980883177156,0.586688600474073E-02,0.196769519930645E-02,0.258110321609986E-01,-0.353871638153577E-02,-0.583864173670300E-03,-5.82625409736547,-9.40393269189297,-8.99279433028253,2.43100054224357,-0.869040046826798,1.39063278042745,6.94813120050731,-1.09229973626963,5700.50854139221,-1970.53440337706,945.922057843459,-1148.03055702037,506.689744560469,-260.986403837064,-0.340270079775437E-02,-0.301799003378707E-02,0.273077811081449E-03,-0.749804998031316E-05,0.659294953129241E-01,-0.159116115134032E-02,-0.581006471459365E-02,0.654393101033610E-03,-0.505793980246535E-04,0.242876108982219E-06,0.750863973418521E-01,-0.531641087075738E-01,-0.357649225569677E-01,0.590441704929394E-02,0.335266512317128E-01,-0.107731140678047E-02,-5.14241258813587,0.592038026424650,3.83030358107744,-0.697828895361904,-1.71656123712510,0.395681569698488,-0.199889684588889E-01,0.281931903767914E-02,0.333117349482874E-02,-0.460888898714435E-03,-0.979004590189350E-05,-0.117717839696565E-05,-0.269778785645592E-01,0.774423608165372E-02,-0.199393453975153E-02,0.348461672694284E-02,-0.241328704164402E-03,0.170228530175656E-04,0.694905217993850,-0.385769551844958,-1.44514126863297,0.262751891295684,0.706257853169820,-0.664692990076174E-02,0.410538412289175E-02,-0.258843782864093E-01,-55.3871136556350,15.0705244060192,25.4089220257961,-6.79834207762229,5.28871252446790,-1.82799668096280,-6.98882696125774,1.69368962612510,-0.271392184593915E-02,-0.351505110780065E-03,-0.425784565441816E-02,0.585160776882054E-03,-0.593449247554803E-03,0.181614036614160E-03,-0.320781269605025E-04,-0.557978849369850E-05,-0.458445457044589E-01,0.159950612006165E-01,-0.530077314995729E-02,0.385271079332501E-01,-0.714302314624132E-02,-0.109155161114916E-02,0.228505407705493,-0.250380013087819,-0.384402269648386E-01,0.110899894736948E-01,-0.742029371319280E-02,0.506250785869552E-01,-0.705252007004438E-02,-0.936260258406431E-02,-14.2730508812110,-3.72603375588112,11.4487965802575,-2.00507376133518,-17.0902855630745,10.3130243728514,0.740879598308153,-0.739812067665718,-9.41384046175960,0.616658702078616,0.402358894096069,2.01644481592022,-0.369272245806151,-0.662281931057704E-01,27.7922654904720,-12.1948190643027,-7.54964608995773,3.28085709602647,-4.53614217750377,3.84164944486320,1.39004011744639,-0.943946187949185,-0.552552864668574,0.341486164202835E-01,-0.155658850343474E-01,0.963437069717453E-01,-0.476097357227456E-02,0.305450226443552E-02,-0.209639335136934E-01,-0.265943625946831E-02,0.464289265527990E-03,-0.114055359129251E-04,-103.531530887844,13.8675587231737,24.2698634001793,-3.18530770837304,-4.92421347711677,0.665653060494782,147.613132536345,-61.9351263440442,-35.3602167281432,15.9102153929414,11.8153125514402,-5.11477306871812,0.110233672253137E-01,-0.108314827346119E-02,0.868612936071408E-03,-0.155681958775002E-03,0.796247237295817E-04,0.236338739997899E-05,-32.1089192666920,9.98787218827249,-3.24588947036590,8.18668875392146,-2.29949127413238,0.687301109446222,-31.0290515352438,10.1824000412681,9.39967775769931,-3.06640103651431,7.40696119616476,-2.45582557683647,-2.63275705597002,0.896106708902573,534.771027869024,-152.582519329283,-115.461591566858,28.4314866649193,55.0178212252399,-23.0145962098580,7.44436603275125,-0.675697435861911,18.9447600729837,-0.647125490617642,1.69916330684765,-10.7516980275732,1.52947684273799,-0.644730388309686E-02,-34.6949493156220,15.8325912953335,13.5812402509323,-4.88448480202936,1.52894555980386,-2.97697586672866,-2.20832235007076,1.15994667572934,-0.545834299411535E-02,0.334154117076775E-01,0.225288486326517E-02,0.164416104481903E-01,-0.867497359079342E-02,-0.330591171375579E-03,-0.438269678679515E-03,0.267404876596260E-03,-0.400347880281199E-04,0.170419317604112E-04,0.666169747466725E-02,-0.138010944667831E-03,-0.387197784797302E-03,-0.103093509096938E-04,0.810077654991912E-04,0.176363144636544E-04,25159.5664096120,-5721.00532209153,-7355.77103330027,1612.39648131954,1984.65447807106,-431.662183278825,0.204291937103272E-01,-0.238410947113184E-02,0.111524869994202E-03,-0.313826317866110E-02,0.598522311418969E-03,-0.222047308362862E-04,116.868146587442,-83.8193688789445,12.7681442692600,21.4045905031313,17.6035587146334,22.4480446587023,-18.9276222657181,-5.15174371164953,-900529.197297226,517364.551836936,-375299.162905634,279464.697529691,-128361.933771767,86955.5108273582,-0.604187861716898E-03,0.196961033901995E-02,-0.353285679601214E-03,0.201029922116205E-03,-23.0707930464000,6.36605555968096,6.90527906965097,-1.59617164979259,-3.56636998611403,0.547533504354795,-37.5675719376541,210.485834995817,-90.8479109714213,100.276508067286,-71.9533358358070,26.4701958405540,-21646.4626840351,10840.5844912191,-5313.78523618286,2386.16242885918};
    
    protected static final int[][] ind3_beta = new int[][]{
        {45,46,46,47,47,48,48,48,48,55,55,55,55,60,60,60,60},
        {46,49,49,50,50,51,51,51,51,56,56,56,56,61,61,61,61},
        {46,49,49,50,50,51,51,51,51,56,56,56,56,61,61,61,61},
        {47,50,50,52,52,53,53,53,53,57,57,57,57,62,62,62,62},
        {47,50,50,52,52,53,53,53,53,57,57,57,57,62,62,62,62},
        {48,51,51,53,53,54,54,54,54,58,58,58,58,63,63,63,63},
        {48,51,51,53,53,54,54,54,54,58,58,58,58,63,63,63,63},
        {48,51,51,53,53,54,54,54,54,58,58,58,58,63,63,63,63},
        {48,51,51,53,53,54,54,54,54,58,58,58,58,63,63,63,63},
        {55,56,56,57,57,58,58,58,58,59,59,59,59,64,64,64,64},
        {55,56,56,57,57,58,58,58,58,59,59,59,59,64,64,64,64},
        {55,56,56,57,57,58,58,58,58,59,59,59,59,64,64,64,64},
        {55,56,56,57,57,58,58,58,58,59,59,59,59,64,64,64,64},
        {60,61,61,62,62,63,63,63,63,64,64,64,64,65,65,65,65},
        {60,61,61,62,62,63,63,63,63,64,64,64,64,65,65,65,65},
        {60,61,61,62,62,63,63,63,63,64,64,64,64,65,65,65,65},
        {60,61,61,62,62,63,63,63,63,64,64,64,64,65,65,65,65}
    };
    
    protected static final int[][] ind3_gamma = new int[][]{
        {66,67,67,68,68,69,69,69,69,76,76,76,76,81,81,81,81},
        {67,70,70,71,71,72,72,72,72,77,77,77,77,82,82,82,82},
        {67,70,70,71,71,72,72,72,72,77,77,77,77,82,82,82,82},
        {68,71,71,73,73,74,74,74,74,78,78,78,78,83,83,83,83},
        {68,71,71,73,73,74,74,74,74,78,78,78,78,83,83,83,83},
        {69,72,72,74,74,75,75,75,75,79,79,79,79,84,84,84,84},
        {69,72,72,74,74,75,75,75,75,79,79,79,79,84,84,84,84},
        {69,72,72,74,74,75,75,75,75,79,79,79,79,84,84,84,84},
        {69,72,72,74,74,75,75,75,75,79,79,79,79,84,84,84,84},
        {76,77,77,78,78,79,79,79,79,80,80,80,80,85,85,85,85},
        {76,77,77,78,78,79,79,79,79,80,80,80,80,85,85,85,85},
        {76,77,77,78,78,79,79,79,79,80,80,80,80,85,85,85,85},
        {76,77,77,78,78,79,79,79,79,80,80,80,80,85,85,85,85},
        {81,82,82,83,83,84,84,84,84,85,85,85,85,86,86,86,86},
        {81,82,82,83,83,84,84,84,84,85,85,85,85,86,86,86,86},
        {81,82,82,83,83,84,84,84,84,85,85,85,85,86,86,86,86},
        {81,82,82,83,83,84,84,84,84,85,85,85,85,86,86,86,86}
    };

    protected static final int[][] ind3_R0 = new int[][]{
        {87,88,88,89,89,90,90,90,90,97,97,97,97,102,102,102,102},
        {88,91,91,92,92,93,93,93,93,98,98,98,98,103,103,103,103},
        {88,91,91,92,92,93,93,93,93,98,98,98,98,103,103,103,103},
        {89,92,92,94,94,95,95,95,95,99,99,99,99,104,104,104,104},
        {89,92,92,94,94,95,95,95,95,99,99,99,99,104,104,104,104},
        {90,93,93,95,95,96,96,96,96,100,100,100,100,105,105,105,105},
        {90,93,93,95,95,96,96,96,96,100,100,100,100,105,105,105,105},
        {90,93,93,95,95,96,96,96,96,100,100,100,100,105,105,105,105},
        {90,93,93,95,95,96,96,96,96,100,100,100,100,105,105,105,105},
        {97,98,98,99,99,100,100,100,100,101,101,101,101,106,106,106,106},
        {97,98,98,99,99,100,100,100,100,101,101,101,101,106,106,106,106},
        {97,98,98,99,99,100,100,100,100,101,101,101,101,106,106,106,106},
        {97,98,98,99,99,100,100,100,100,101,101,101,101,106,106,106,106},
        {102,103,103,104,104,105,105,105,105,106,106,106,106,107,107,107,107},
        {102,103,103,104,104,105,105,105,105,106,106,106,106,107,107,107,107},
        {102,103,103,104,104,105,105,105,105,106,106,106,106,107,107,107,107},
        {102,103,103,104,104,105,105,105,105,106,106,106,106,107,107,107,107}
    };
    
    protected static final int[][] ind_d1 = new int[][]{{27,28,28,30,30},
                {28,29,29,31,31},
                {28,29,29,31,31},
                {30,31,31,32,32},
                {30,31,31,32,32}};

    protected static final int[][] ind_d6 = new int[][]{{92,93,93},
                {93,94,94},
                {93,94,94}};

    protected static final int[][] ind_d8 = new int[][]{{95,96,96},
                {96,97,97},
                {96,97,97}};

    protected static final int[][] ind_d10 = new int [][]{{98,99,99},
               {99,100,100},
               {99,100,100}};

    protected static final int[][] ind_C6 =new int[][]{{83,84,84},
                {84,85,85},
                {84,85,85}};

    protected static final int[][] ind_C8 = new int[][]{{86,87,87},
                {87,88,88},
                {87,88,88}};

    protected static final int[][] ind_C10 = new int[][]{{89,90,90},
                {90,91,91},
                {90,91,91}};

    public static Vector[] getSites(Space space) {
        Vector[] siteV = new Vector[siteDoubles.length];
        double bohrConv = BohrRadius.UNIT.toSim(1);
        for (int i=0; i<siteV.length; i++) {
            siteV[i] = Vector.of(siteDoubles[i]);
            siteV[i].TE(bohrConv);
        }
        return siteV;
    }
    
    public static double[] getQ() {
        double[] q = new double[5];
        Unit unit = new CompoundUnit(new Unit[]{Hartree.UNIT,BohrRadius.UNIT}, new double[]{0.5,0.5});
        for (int i=0; i<5; i++) {
            q[i] = unit.toSim(params[ind_charge[i]]);
        }
        return q;
    }
    
    protected static final double gamma=20, R0=1.4;
    protected final Vector[][] sitePos;
    protected final Vector[] com0;
    protected final Vector rTmp;
    protected final Vector or2;
    protected final Vector[] allOr;
    protected static final int npol = 3;
    protected final Vector[][] E0;
    protected final Vector E1, polE1;
    protected final int[][][][][][] ind_lin;
    public enum Component {
        ALL, INDUCTION, TWO_BODY, NON_PAIR, THREE_BODY
    }
    protected Component component = Component.ALL;
    protected final double[] aj3;
    protected final double bohrConv = BohrRadius.UNIT.fromSim(1);
    protected final Space space;
    
    public P2WaterSzalewicz(Space space, int nBody) {
        this.space = space;
        sitePos = new Vector[nBody][sites.length];
        com0 = new Vector[nBody];
        for (int j=0; j<nBody; j++) {
            com0[j] = space.makeVector();
            for (int i=0; i<sites.length; i++) {
                sitePos[j][i] = space.makeVector();
                sitePos[j][i] = space.makeVector();
            }
        }

        rTmp = space.makeVector();
        or2 = space.makeVector();
        allOr = new Vector[]{null,null,or2};
        Rpol = new Vector[nBody*npol];
        Gpol = new Vector[nBody*npol];
        for (int i=0; i<nBody*npol; i++) {
            Rpol[i] = space.makeVector();
            Gpol[i] = space.makeVector();
        }
        E0 = new Vector[nBody][npol];
        for (int i=0; i<nBody; i++) {
            for (int j=0; j<npol; j++) {
                E0[i][j] = space.makeVector();
            }
        }
        E1 = space.makeVector();
        polE1 = space.makeVector();
        distPol = new double[nBody*npol][nBody*npol];
        dmptab = new double[nBody*npol][nBody*npol];
        H1O = space.makeVector();
        H2O = space.makeVector();
        epom = space.makeVector();
        sep = space.makeVector();
        if (nBody>=3) {
            com3 = new Vector[3];
            sitePos3 = new Vector[3][sites.length];
            S2 = space.makeVector();
            S3 = space.makeVector();
        }
        else {
            com3 = null;
            sitePos3 = null;
            S2 = S3 = null;
        }

        int lmax = 1;
        ind_lin = new int[nsite3][nsite3][nsite3][lmax+1][lmax+1][lmax+1];
        int inew=0;
        for (int iat=0; iat<nsite3; iat++) {
            for (int jat=0; jat<nsite3; jat++) {
                for (int kat=0; kat<nsite3; kat++) {
                    for (int ip=0; ip<2; ip++) {
                        for (int jp=0; jp<2; jp++) {
                            for (int kp=0; kp<2; kp++) {
                                if (ind_lin[iat][jat][kat][ip][jp][kp] == 0) {
                                    fill(iat, jat, kat, ip, jp, kp, inew);
//                                    System.out.println("inew="+inew);
                                    inew++;
                                }
                            }
                        }
                    }
                }
            }
        }
        nlin3 = inew;
        aj3 = new double[nlin3];
    }
    
    protected void fill(int iat, int jat, int kat, int ip, int jp, int kp, int nr) {
        int[] ntype = new int[]{1,2,2,3,3,4,4,4,4,5,5,5,5,6,6,6,6};

        boolean ilook=true;
        boolean jlook=true;
        boolean klook=true;
        int ifrst = -1, jfrst=-1, kfrst=-1;
        int ilast=-1, jlast=-1, klast=-1;
        for (int ns=0; ns<nsite3; ns++) {
           if ((ntype[iat]==ntype[ns])&&ilook) {
              ifrst=ns;
              ilook=false;
           }
           if ((ntype[jat]==ntype[ns]) && jlook) {
              jfrst=ns;
              jlook=false;
           }
           if ((ntype[kat]==ntype[ns])&&klook) {
              kfrst=ns;
              klook=false;
           }
           if (ntype[iat]==ntype[ns]) {
              if (ns==nsite3-1) {
                 ilast=ns;
              }
              else {
                 if (ntype[iat]!=ntype[ns+1]) ilast=ns;
              }
           }
           if (ntype[jat]==ntype[ns]) {
              if (ns==nsite3-1) {
                 jlast=ns;
              }
              else {
                 if (ntype[jat]!=ntype[ns+1]) jlast=ns;
              }
           }
           if (ntype[kat]==ntype[ns]) {
              if (ns==nsite3-1) {
                 klast=ns;
              }
              else {
                 if (ntype[kat]!=ntype[ns+1]) klast=ns;
              }
           }
        }

//        System.out.println(nr+" "+ifrst+" "+ilast+" "+jfrst+" "+jlast+" "+kfrst+" "+klast);
        for (int i=ifrst; i<=ilast; i++) {
            for (int j=jfrst; j<=jlast; j++) {
                for (int k=kfrst; k<=klast; k++) {
                    ind_lin[ k][j][i][kp][jp][ip]=nr;
                    ind_lin[ j][k][i][jp][kp][ip]=nr;
                    ind_lin[ i][k][j][ip][kp][jp]=nr;
                    ind_lin[ k][i][j][kp][ip][jp]=nr;
                    ind_lin[ i][j][k][ip][jp][kp]=nr;
                    ind_lin[ j][i][k][jp][ip][kp]=nr;
                }
            }
        }
    }
    
    public void setComponent(Component newComponent) {
        component = newComponent;
    }

    public double virial(IAtomList atoms) {
        return 0;
    }

    public Vector[] gradient(IAtomList atoms) {
        return null;
    }

    public Vector[] gradient(IAtomList atoms, Tensor pressureTensor) {
        return null;
    }

    protected static final int nlin=144;
    protected final int nlin3;
    protected final double[] aj = new double[nlin];
    protected static final double core = 1.2;
    public static boolean debug = false;

    public double energy(IAtomList atoms) {
        for (int i = 0; i<atoms.size(); i++) {
            rTmp.Ea1Tv1(bohrConv, atoms.get(i).getPosition());
            // everything after this is in Bohr
            OrientationFull3D ori = (OrientationFull3D)((IAtomOriented)atoms.get(i)).getOrientation();
            allOr[0] = ori.getDirection();
            allOr[1] = ori.getSecondaryDirection();
            or2.E(allOr[0]);
            or2.XE(allOr[1]);
            for (int j=0; j<sites.length; j++) {
                sitePos[i][j].E(rTmp);
                for (int k=0; k<3; k++) {
                    sitePos[i][j].PEa1Tv1(sites[j].getX(k), allOr[k]);
                }
            }
            com0[i].E(rTmp);
            // according to our atomic masses, the COM is not at 0,0,0
            // we shifted the positions from siteDoubles to sitePos so that the COM is at 0,0,0
            // however, the original COM is used for 3-body interactions.  compute that now
            com0[i].PEa1Tv1(-cmzFix, allOr[2]);
        }

        double u0 = 0;
        if (component != Component.INDUCTION && component != Component.NON_PAIR && component != Component.THREE_BODY) {

            for (int iA = 0; iA<atoms.size()-1; iA++) {
                for (int iB = iA+1; iB<atoms.size(); iB++) {
                    double minR = 10000;
                    double E_ele=0;
                    double E_ind=0;
                    double E_exp=0;
                    for (int i=0; i<nlin; i++) {
                        aj[i] = 0;
                    }
                    for (int nsA=0; nsA<sites.length; nsA++) {
                        for (int nsB=0; nsB<sites.length; nsB++) {

                            double R2 = sitePos[iA][nsA].Mv1Squared(sitePos[iB][nsB]);
                            double R = Math.sqrt(R2);
                            if (R<minR) minR = R;
                            if (R<core) return Double.POSITIVE_INFINITY;

                            int ib = ind_beta[nsA][nsB]-1;
                            // every pair of sites has exp
                            double beta = params[ib];
                            double eks = Math.exp(-beta * R);
                            int indlin = ib - 98;
                            if (indlin < 0) indlin = indlin + 65;
                            int ind0 = indlin;
                            int ind1 = ind0 + 36;
                            int ind2 = ind1 + 36;
                            int ind3 = ind2 + 36;
                            aj[ind0] = aj[ind0] + eks;
                            aj[ind1] = aj[ind1] + eks * R;
                            aj[ind2] = aj[ind2] + eks * R2;
                            aj[ind3] = aj[ind3] + eks * R*R2;
                            // damp the site-site u_exp function if u_exp is negative
                            double u_exp = eks * (c[ind0] + c[ind1]*R + c[ind2]*R2 + c[ind3]*R2*R);
                            if (u_exp < 0) {
                                double fdamp = 1 / (1 + Math.exp(-gamma*(R-R0)));
                                u_exp *= fdamp;
                                aj[ind0] = aj[ind0] * fdamp;
                                aj[ind1] = aj[ind1] * fdamp;
                                aj[ind2] = aj[ind2] * fdamp;
                                aj[ind3] = aj[ind3] * fdamp;
                            }
                            E_exp += u_exp;
            
                            if (nsA < 5 && nsB < 5) { // elst
                               double qA = params[ind_charge[nsA]];
                               double qB = params[ind_charge[nsB]];
                               double d1 = params[ind_d1[nsA][nsB]];
                               double f1 = damp(1,d1,R);
                               E_ele = E_ele+ f1* qA*qB/R;
                            }
            
                            
                            if (nsA < 3 && nsB < 3) {    // ind-disp
                                double d6 = params[ind_d6[nsA][nsB]];
                                double d8 = params[ind_d8[nsA][nsB]];
                                double d10 = params[ind_d10[nsA][nsB]];
                                double C6 = params[ind_C6[nsA][nsB]];
                                double C8 = params[ind_C8[nsA][nsB]];
                                double C10 = params[ind_C10[nsA][nsB]];
                                double f6 = damp(6,d6,R);
                                double f8 = damp(8,d8,R);
                                double f10 = damp(10,d10,R);
                                double R6 = R2*R2*R2;
                                double R8 = R6*R2;
                                double R10 = R8*R2;
                                E_ind = E_ind -f6*C6/R6 -f8*C8/R8 -f10*C10/R10;
                            }
            
                        }
                    }
                    if (debug) {
                        System.out.println(String.format("% 12.6e  % 12.6e  % 12.6e  ", E_exp, E_ele, E_ind));
                    }
                    u0 += E_exp + E_ele + E_ind;
//                    for (int nl=0; nl<nlin; nl++) {
//                        u0 += c[nl]*aj[nl];
//                    }

                    if (false) {
                        if (nBody() == 2 && Hartree.UNIT.toSim(u0) < -2200) {
                            System.out.println("in here "+minR+" "+Hartree.UNIT.toSim(u0));
                        }
                        if (nBody() == 2 && Hartree.UNIT.toSim(u0) < 1000 && minR < 1.8) {
                            System.out.println("in here "+minR+" "+Hartree.UNIT.toSim(u0));
                        }
                    }
                }
            }
        }

        double uInd = 0;
        if (component != Component.TWO_BODY && component != Component.THREE_BODY) {
            uInd = indN_iter();
        }
        double u3 = 0;
        if (component != Component.TWO_BODY && component != Component.INDUCTION) {
            for (int i = 0; i<atoms.size()-2; i++) {
                com3[0] = com0[i];
                sitePos3[0] = sitePos[i];
                for (int j = i+1; j<atoms.size()-1; j++) {
                    com3[1] = com0[j];
                    sitePos3[1] = sitePos[j];
                    for (int k = j+1; k<atoms.size(); k++) {
                        com3[2] = com0[k];
                        sitePos3[2] = sitePos[k];
                        u3 += fit3b();
                    }
                }
            }
        }
        return Hartree.UNIT.toSim(u0 + uInd + u3);
    }

    /**
     * Prints atom coordinates and euler angles in a format compatible with the CCpol fortran program
     * The orientations are taken from the given atoms.  The com0 array is assumed to be set up.  Call
     * this method after calling energy or from within the energy method itself.
     */
    public void printFortranInput(IAtomList atoms) {
        for (int i = 0; i < atoms.size(); i++) {
            OrientationFull3D o = (OrientationFull3D) ((IAtomOriented) atoms.get(i)).getOrientation();
            double[] euler = eulerFromOrientation(o);
            System.out.println(com0[i].getX(0) + " " + com0[i].getX(1) + " " + com0[i].getX(2) + " " + euler[0] / Math.PI * 180 + " " + euler[1] / Math.PI * 180 + " " + euler[2] / Math.PI * 180);
        }
    }

    protected double[] eulerFromOrientation(OrientationFull3D or) {
        Vector3D or1 = (Vector3D) or.getDirection();
        Vector3D or2 = (Vector3D) or.getSecondaryDirection();
        Vector3D or3 = new Vector3D();
        or3.E(or1);
        or3.XE(or2);
        double beta = -Math.acos(or3.getX(2));
        double alpha = Math.atan2(or3.getX(1), or3.getX(0));
        double o30 = Math.sin(beta) * Math.cos(alpha);
        if (o30 * or3.getX(0) < 0) {
            // wrong sign
            alpha += Math.PI;
            // or beta = -beta
        }
        double gamma = Math.atan2(-or2.getX(2), or1.getX(2));
        double o22 = Math.sin(beta) * Math.sin(gamma);
        if (o22 * or2.getX(2) < 0) {
            // wrong sign
            gamma += Math.PI;
        }
        return new double[]{alpha, beta, gamma};
    }
    
    protected double damp(int n, double beta, double r) {
        double br=beta*r;
        
        if(br==0) {
            return 0;
        }
        double sum=1.0;
        double term=1.0;
        for (int i=1; i<=n; i++) {
            term*=br/i;
            sum+=term;
        }

        double damp=1.0 - Math.exp(-br)*sum;
        // in case of d --> 0 use
        // d=1.0d0 - dexp(-br)*sum = sum_m=n+1^\infty br^m/m!
        if(Math.abs(damp)<1.0e-8) {
            damp=0.0;
            for (int i=n+1; i<=1000; i++) {
                term*=br/i;
                damp+=term;
                if(term/damp < 1.0e-8) break;
            }
            if (term/damp > 1e-8) throw new RuntimeException("No convergence in damp"+" "+r);
            damp*=Math.exp(-br);
        }
        //     write(6,'(i4,2f10.5,e20.10)') n,beta,r,d
        return damp;
    }
    
    protected final Vector[] Rpol, Gpol;
    protected final Vector epom;
    protected final double[][] distPol;
    protected final double[][] dmptab;
    protected static final double[] pol = new double[]{6.5186, 1.5507, 1.5507};
    protected static final double[] H1pol = new double[]{0,1,0};
    protected static final double[] H2pol = new double[]{0,0,1};
    protected final Vector H1O, H2O;
    protected final Vector[] com3;
    protected final Vector[][] sitePos3;
    
    /**
     * Compute the iterative induction between N water molecules 
     * using several polarization centers in the molecular plane
     */
    public double indN_iter() {
        int maxit = 200;
        int N = sitePos.length;
        
        double delta2 = 1.65;
        double delta3 = 1.55;
        double dmpfct = 1;
        int maxNpol = npol*N;
        
        for (int j=0; j<maxNpol; j++) {
            Gpol[j].E(0);
        }

        //Compute positions of polarizable sites
        //dist(i,j)= 1.d0/rij**3

        for (int i=0; i<N; i++) {
            H1O.Ev1Mv2(sitePos[i][1], sitePos[i][0]); // H1 minus O
            H2O.Ev1Mv2(sitePos[i][2], sitePos[i][0]); // H2 minus O
            
            for (int np=0; np<npol; np++) {
                int ind = i*npol+np;
                Rpol[ind].E(sitePos[i][0]);
                Rpol[ind].PEa1Tv1(H1pol[np], H1O);
                Rpol[ind].PEa1Tv1(H2pol[np], H2O);
            }
        }

        for (int i=0; i<N; i++) {
            for (int np=0; np<npol; np++) {
                int indi=i*npol+np;
                for (int j=i+1; j<N; j++) {
                    for (int nq=0; nq<npol; nq++) {
                        int indj = j*npol+nq;
                        distPol[indi][indj] = Rpol[indi].Mv1Squared(Rpol[indj]);
                        double distan = Math.sqrt(distPol[indi][indj]);
                        dmpfct = damp(3,delta3,distan);
                        dmptab[indi][indj] = dmpfct;
                        dmptab[indj][indi] = dmpfct;
                        distPol[indi][indj] = Math.pow(distPol[indi][indj], -1.5);
                        distPol[indj][indi] = distPol[indi][indj];
                    }
                }
            }
        }


        for (int i=0; i<N; i++) {
            for (int np=0; np<npol; np++) {
                E0[i][np].E(0);
                for (int j=0; j<N; j++) {
                    if (i==j) continue;
                    efieldBohrDamped(Rpol[i*npol+np], sitePos[j], delta2);
                    // efieldBohrDamped sets epom
                    E0[i][np].PE(epom);
                }
            }
        }


        //   LETS DO IT (the iterations, that is...)

        double thr_iter = 1.e-16;
        double change = 10;
        int isteps = 0;

        double energy= 0.0;
        while (change > thr_iter && isteps < maxit) {
            change= 0.0;
            energy = 0;
            for (int i=0; i<N; i++) {
                for  (int np=0; np<npol; np++) {
                    int indi=i*npol +np;
                    E1.E(E0[i][np]);
                    for (int j=0; j<N; j++) {
                        if (i==j) continue;
                        for (int nq=0; nq<npol; nq++) {
                            int indj=j*npol+nq;
                            Tprod(Rpol[indi], Rpol[indj], Gpol[indj], distPol[indi][indj]);
                            // Tprod sets epom
                            E1.PEa1Tv1(dmptab[indi][indj], epom);
                        }
                    }
                    // total field at ii ready. Place induced dipole....
                    polE1.Ea1Tv1(pol[np], E1);
                    
                    change += Gpol[indi].Mv1Squared(polE1);

                    Gpol[indi].E(polE1);
                    energy += -0.5*pol[np]*E1.dot(E0[i][np]);
                }
            }
            isteps++;
        }

        if (isteps > maxit)  {
           System.out.println("No convergence in indN_iter");
           System.out.println("energy change="+change);
           System.out.println("thr_iter="+thr_iter);
           throw new RuntimeException();
        }
        return energy;
    }

    protected final Vector sep;

    /**
     * Calculate the contribution of molecule b to the field on a
     * Use the CC-pol site charges.
     * Units: input positions of bohr, 
     * output fields in au
     */
    protected void efieldBohrDamped(Vector veci, Vector[] sitebt, double delta) {
        epom.E(0);
        for (int isite=0; isite<sites.length && isite<5; isite++) {
            sep.Ev1Mv2(veci, sitebt[isite]);
            double sepl = sep.squared();
            double distan = Math.sqrt(sepl);
            double myDmptab = damp(2,delta,distan);
            sepl = Math.pow(sepl, -1.5);
            epom.PEa1Tv1(params[ind_charge[isite]]*sepl*myDmptab, sep);
        }
    }        

    /**
     * Calculate the vector V resulting from the action
     * of the dipole propagator tensor T_ij on U
     * Ri, Rj - position vectors of molecules i and j, respectively
     * rij = |Ri - Rj|^(-3)
     */
    protected void Tprod(Vector Ri, Vector Rj, Vector u, double rij) {
        double ddd = Math.pow(rij, 2.0/3.0);
        epom.Ev1Mv2(Ri, Rj);
        double scal = epom.dot(u);
        epom.TE(3*scal*ddd);
        epom.ME(u);
        epom.TE(rij);
    }
    
    protected double fit3b() {
        
        double rc = bohrConv*7;
        double rc2 = rc*rc;
        if (!broken3body && (sitePos3[0][0].Mv1Squared(sitePos3[1][0]) > rc2 ||
                sitePos3[0][0].Mv1Squared(sitePos3[2][0]) > rc2 ||
                sitePos3[1][0].Mv1Squared(sitePos3[2][0]) > rc2)) return 0;


        double AOOex = params3[36];
        double AHHex = params3[37];
        double AOHex = params3[38];
        double betaOO = params3[39];
        double betaHH = params3[40];
        double betaOH = params3[41];
        double exqpos = params3[42];
        
        double a0 = S2fit(AOOex, AHHex, AOHex, betaOO, betaHH, betaOH, exqpos);
        
        Arrays.fill(aj3, 0);
        double u3 = 0;

        for (int nsA=0; nsA<nsite3; nsA++) {
            for (int nsB=0; nsB<nsite3; nsB++) {
                double RAB = Math.sqrt(sitePos3[0][nsA].Mv1Squared(sitePos3[1][nsB]));
                double bAB=params3[ind3_beta[nsA][nsB] - 1];
                double gAB=params3[ind3_gamma[nsA][nsB] - 1];
                double r0AB=params3[ind3_R0[nsA][nsB] - 1];
                for (int nsC=0; nsC<nsite3; nsC++) {
                    double RAC=Math.sqrt(sitePos3[0][nsA].Mv1Squared(sitePos3[2][nsC]));
                    double bAC=params3[ind3_beta[nsA][nsC] - 1];
                    double gAC=params3[ind3_gamma[nsA][nsC] - 1];
                    double r0AC=params3[ind3_R0[nsA][nsC] - 1];

                    double RBC=Math.sqrt(sitePos3[1][nsB].Mv1Squared(sitePos3[2][nsC]));
                    double bBC=params3[ind3_beta[nsB][nsC] - 1];
                    double gBC=params3[ind3_gamma[nsB][nsC] - 1];
                    double r0BC=params3[ind3_R0[nsB][nsC] - 1];
                    double dampAB = 1/(1+Math.exp(-gAB*(RAB-r0AB)));
                    double dampAC = 1/(1+Math.exp(-gAC*(RAC-r0AC)));
                    double dampBC = 1/(1+Math.exp(-gBC*(RBC-r0BC)));
                    
                    double dampABC = dampAB*dampAC*dampBC;
                    
                    if (Double.isNaN(dampABC)) {
                        throw new RuntimeException(""+dampABC);
                    }
                    double eks = Math.exp(-bAB*RAB-bAC*RAC-bBC*RBC)*dampABC;
                    double term1 = eks;
                    for (int ip=0; ip<2; ip++) {
                        double term2 = term1;
                        for (int jp=0; jp<2; jp++) {
                            double term3 = term2;
                            for (int kp=0; kp<2; kp++) {
                                int ind = ind_lin[nsA][nsB][nsC][ip][jp][kp];
                                u3 += term3*c3[ind];
                                aj3[ind] += term3;
                                term3 *= RAB;
                            }
                            term2 *= RAC;
                        }
                        term1 *= RBC;
                    }
                }
            }
        }
        double u = a0 + u3;
//        for (int nl=0; nl<nlin3; nl++) {
//            u += c3[nl]*aj3[nl];
//        }
        return u;
    }

    protected static final int nsite3 = 17;
    protected final int[] ijk = new int[]{0,1,2,-1};
    protected static final double[] chrg3 = new double[]{0.258504607653328389,0.564050362569283648,-0.693302666395947953}; // SAPT-5s_1
    protected final Vector S2, S3;
    protected double S2fit(double AOOex, double AHHex, double AOHex, double betaOO, double betaHH, double betaOH, double exqpos) {
        double energy = 0;
        for (int iijk=0; iijk<3; iijk++) {
            int ii = ijk[0];
            int jj = ijk[1];
            int kk = ijk[2];
            Vector C2 = com3[jj];
            Vector C3 = com3[kk];
            double Rsep = Math.sqrt(C2.Mv1Squared(C3));
            double OOsep = Math.sqrt(sitePos3[jj][0].Mv1Squared(sitePos3[kk][0]));
            double HH1sep = Math.sqrt(sitePos3[jj][1].Mv1Squared(sitePos3[kk][1]));  // H1-H1
            double HH2sep = Math.sqrt(sitePos3[jj][1].Mv1Squared(sitePos3[kk][2]));  // H1-H2
            double HH3sep = Math.sqrt(sitePos3[jj][2].Mv1Squared(sitePos3[kk][1]));  // H2-H1
            double HH4sep = Math.sqrt(sitePos3[jj][2].Mv1Squared(sitePos3[kk][2]));  // H2-H2
            double OH1sep = Math.sqrt(sitePos3[jj][0].Mv1Squared(sitePos3[kk][1]));  // O-H1
            double OH2sep = Math.sqrt(sitePos3[jj][0].Mv1Squared(sitePos3[kk][2]));  // O-H2
            double OH3sep = Math.sqrt(sitePos3[jj][1].Mv1Squared(sitePos3[kk][0]));  // H1-O
            double OH4sep = Math.sqrt(sitePos3[jj][2].Mv1Squared(sitePos3[kk][0]));  // H2-O
            
            double q1 = AOOex*Math.exp(-betaOO*OOsep);
            double q2 = AHHex*Math.exp(-betaHH*HH1sep);
            double q3 = AHHex*Math.exp(-betaHH*HH2sep);
            double q4 = AHHex*Math.exp(-betaHH*HH3sep);
            double q5 = AHHex*Math.exp(-betaHH*HH4sep);
            double q6 = AOHex*Math.exp(-betaOH*OH1sep);
            double q7 = AOHex*Math.exp(-betaOH*OH2sep);
            double q8 = AOHex*Math.exp(-betaOH*OH3sep);
            double q9 = AOHex*Math.exp(-betaOH*OH4sep);
            q1 *= q1;
            q2 *= q2;
            q3 *= q3;
            q4 *= q4;
            q5 *= q5;
            q6 *= q6;
            q7 *= q7;
            q8 *= q8;
            q9 *= q9;
            
            double qind = q1+q2+q3+q4+q5+q6+q7+q8+q9;
            
            double rRsep = 1.0/Rsep;
            double a = exqpos*rRsep;
            S2.Ea1Tv1(1+a, C2);
            S2.PEa1Tv1(-a, C3);
            S3.Ea1Tv1(-a, C2);
            S3.PEa1Tv1(1+a, C3);
            
            double dS2O = 1/Math.sqrt(S2.Mv1Squared(sitePos3[ii][0]));
            double dS2H1 = 1/Math.sqrt(S2.Mv1Squared(sitePos3[ii][1]));
            double dS2H2 = 1/Math.sqrt(S2.Mv1Squared(sitePos3[ii][2]));
            double dS2B7 = 1/Math.sqrt(S2.Mv1Squared(sitePos3[ii][3]));
            double dS2B8 = 1/Math.sqrt(S2.Mv1Squared(sitePos3[ii][4]));
            
            double dC2O = 1/Math.sqrt(C2.Mv1Squared(sitePos3[ii][0]));
            double dC2H1 = 1/Math.sqrt(C2.Mv1Squared(sitePos3[ii][1])); 
            double dC2H2 = 1/Math.sqrt(C2.Mv1Squared(sitePos3[ii][2]));
            double dC2B7 = 1/Math.sqrt(C2.Mv1Squared(sitePos3[ii][3]));
            double dC2B8 = 1/Math.sqrt(C2.Mv1Squared(sitePos3[ii][4]));

            double dS3O = 1/Math.sqrt(S3.Mv1Squared(sitePos3[ii][0]));
            double dS3H1 = 1/Math.sqrt(S3.Mv1Squared(sitePos3[ii][1])); 
            double dS3H2 = 1/Math.sqrt(S3.Mv1Squared(sitePos3[ii][2]));
            double dS3B7 = 1/Math.sqrt(S3.Mv1Squared(sitePos3[ii][3]));
            double dS3B8 = 1/Math.sqrt(S3.Mv1Squared(sitePos3[ii][4]));
            
            double dC3O = 1/Math.sqrt(C3.Mv1Squared(sitePos3[ii][0]));
            double dC3H1 = 1/Math.sqrt(C3.Mv1Squared(sitePos3[ii][1])); 
            double dC3H2 = 1/Math.sqrt(C3.Mv1Squared(sitePos3[ii][2]));
            double dC3B7 = 1/Math.sqrt(C3.Mv1Squared(sitePos3[ii][3]));
            double dC3B8 = 1/Math.sqrt(C3.Mv1Squared(sitePos3[ii][4]));

            double term = qind*(chrg3[0]*(dC2O + dC3O - dS2O - dS3O)
                               +chrg3[1]*(dC2H1 + dC2H2 + dC3H1 + dC3H2 - dS2H1 - dS2H2 - dS3H1 - dS3H2)
                               +chrg3[2]*(dC2B7 + dC2B8 + dC3B7 + dC3B8 - dS2B7 - dS2B8 - dS3B7 - dS3B8));
            if (Double.isNaN(term) || Double.isInfinite(term)) throw new RuntimeException("oops "+term);
            energy += term;
            for (int i=2; i>=0; i--) {
                ijk[i+1] = ijk[i];
            }
            ijk[0] = ijk[3];
        }
        return energy;
    }
        
    public double getRange() {
        return 0;
    }

    public void setBox(Box box) {

    }

    public int nBody() {
        return sitePos.length;
    }

    public Vector[][] gradientAndTorque(IAtomList atoms) {
        return null;
    }
    
    public P2H2OSC makeSemiclassical(double temperature) {
        return new P2H2OSC(temperature);
    }
    
    public class P2H2OSC implements IPotentialAtomic {
        
        protected final double[] drvDamp;
        protected final Vector[][] gi;
        protected final Tensor tt0Tensor, tt1Tensor, rr0Tensor, rr1Tensor;
        protected final Tensor ijTensor, rTensor0, rTensor1, identity;
        protected final Tensor ijRTensor;
        protected final Tensor[] rot;
        protected final Vector drijRot;
        public double[][] d2tot;
        protected final double temperature, fac;
        protected final Vector drij;
        protected final Vector moment;
        protected final Vector ri, rj;
        
        public P2H2OSC(double temperature) {
            drvDamp = new double[6];
            drij = space.makeVector();
            ijTensor = space.makeTensor();
            identity = space.makeTensor();
            tt0Tensor = space.makeTensor();
            tt1Tensor = space.makeTensor();
            rr0Tensor = space.makeTensor();
            rr1Tensor = space.makeTensor();
            rTensor0 = space.makeTensor();
            rTensor1 = space.makeTensor();
            ijRTensor = space.makeTensor();
            identity.E(new double[][]{{1,0,0},{0,1,0},{0,0,1}});
            gi = new Vector[2][sites.length];
            for (int i=0; i<sites.length; i++) {
                gi[0][i] = space.makeVector();
                gi[1][i] = space.makeVector();
            }
            drijRot = space.makeVector();
            rot = new Tensor[sitePos.length];
            for (int i=0; i<rot.length; i++) {
                rot[i] = space.makeTensor();
            }
            
            this.temperature = temperature;
            double hbar = Constants.PLANCK_H/(2*Math.PI);
            fac = hbar*hbar/(24/2)/temperature;
            
            moment = space.makeVector();
            moment.setX(0, 2*Hydrogen.INSTANCE.getMass()*siteDoubles[1][2]*siteDoubles[1][2] + Oxygen.INSTANCE.getMass()*siteDoubles[0][2]*siteDoubles[0][2]);
            moment.setX(1, 2*Hydrogen.INSTANCE.getMass()*sites[1].squared() + Oxygen.INSTANCE.getMass()*sites[0].squared());
            moment.setX(2, 2*Hydrogen.INSTANCE.getMass()*siteDoubles[1][0]*siteDoubles[1][0]);
            
            ri = space.makeVector();
            rj = space.makeVector();
            d2tot = new double[sitePos.length][6];
        }

        public double getRange() {
            return Double.POSITIVE_INFINITY;
        }

        public void setBox(Box box) {
            
        }

        public int nBody() {
            return sitePos.length;
        }

        public double energy(IAtomList atoms) {
            for (int i = 0; i<atoms.size(); i++) {
                rTmp.Ea1Tv1(bohrConv, atoms.get(i).getPosition());
                // everything after this is in Bohr
                OrientationFull3D ori = (OrientationFull3D)((IAtomOriented)atoms.get(i)).getOrientation();
                allOr[0] = ori.getDirection();
                allOr[1] = ori.getSecondaryDirection();
                or2.E(allOr[0]);
                or2.XE(allOr[1]);
                for (int j=0; j<sites.length; j++) {
                    sitePos[i][j].E(rTmp);
                    for (int k=0; k<3; k++) {
                        sitePos[i][j].PEa1Tv1(sites[j].getX(k), allOr[k]);
                    }
                }
                
                rot[i].E(allOr);
                rot[i].invert();
                
                com0[i].E(rTmp);
                // according to our atomic masses, the COM is not at 0,0,0
                // we shifted the positions from siteDoubles to sitePos so that the COM is at 0,0,0
                // however, the original COM is used for 3-body interactions.  compute that now
                com0[i].PEa1Tv1(cmzFix, allOr[2]);
            }

            double u0 = 0;
            double d2tsum = 0, d2rsum = 0;
            if (component != Component.INDUCTION && component != Component.NON_PAIR && component != Component.THREE_BODY) {
                for (int iA = 0; iA<atoms.size()-1; iA++) {
                    for (int iB = iA+1; iB<atoms.size(); iB++) {
                        tt0Tensor.E(0);
                        tt1Tensor.E(0);
                        rr0Tensor.E(0);
                        rr1Tensor.E(0);
                        for (int i=0; i<sites.length; i++) {
                            gi[0][i].E(0);
                            gi[1][i].E(0);
                        }
                        for (int nsA=0; nsA<sites.length; nsA++) {
                            rTensor0.setComponent(0, 1, siteDoubles[nsA][2]);
                            rTensor0.setComponent(1, 0, -siteDoubles[nsA][2]);
                            rTensor0.setComponent(0, 2, -siteDoubles[nsA][1]);
                            rTensor0.setComponent(2, 0, siteDoubles[nsA][1]);
                            rTensor0.setComponent(1, 2, siteDoubles[nsA][0]);
                            rTensor0.setComponent(2, 1, -siteDoubles[nsA][0]);
                            for (int nsB=0; nsB<sites.length; nsB++) {
                                rTensor1.setComponent(0, 1, siteDoubles[nsB][2]);
                                rTensor1.setComponent(1, 0, -siteDoubles[nsB][2]);
                                rTensor1.setComponent(0, 2, -siteDoubles[nsB][1]);
                                rTensor1.setComponent(2, 0, siteDoubles[nsB][1]);
                                rTensor1.setComponent(1, 2, siteDoubles[nsB][0]);
                                rTensor1.setComponent(2, 1, -siteDoubles[nsB][0]);
                
                                drij.Ev1Mv2(sitePos[iB][nsB], sitePos[iA][nsA]);
//                                if (nsA==1&&nsB==2) System.out.println(nsA+" "+nsB+" "+drij);
                                double R2 = drij.squared();
                                double R = Math.sqrt(R2);
                                if (R<core) return Double.POSITIVE_INFINITY;
                                double u = 0;
                                double rdudr = 0;
                                double r2d2udr2 = 0;
                
                                int ib = ind_beta[nsA][nsB]-1;
                                if (ib != 0) {  // exponential
                                   double beta = params[ib];
                                   double eks = Math.exp(-beta*R);
                                   int indlin=ib-98;
                                   if (indlin<0) indlin=indlin+65;
                                   int ind0= indlin;
                                   int ind1= ind0+36;
                                   int ind2= ind1+36;
                                   int ind3= ind2+36;
//                                   aj[ind0] = aj[ind0] +eks;
//                                   aj[ind1] = aj[ind1] +eks*R;
//                                   aj[ind2] = aj[ind2] +eks*R*R;
//                                   aj[ind3] = aj[ind3] +eks*R*R*R;
                                // damp the site-site u_exp function if u_exp is negative
                                   double u_exp = eks*( c[ind0] +c[ind1]*R +c[ind2]*R2 +c[ind3]*R2*R );
                                   if (u_exp < 0) {
                                       double fdamp = 1/( 1+Math.exp(-gamma*(R-R0)) );
//                                       aj[ind0] = aj[ind0] *fdamp;
//                                       aj[ind1] = aj[ind1] *fdamp;
//                                       aj[ind2] = aj[ind2] *fdamp;
//                                       aj[ind3] = aj[ind3] *fdamp;
//                                       System.out.println("usc "+nsA+" "+nsB+" "+u_exp+" "+fdamp+" "+u_exp*fdamp);
                                       u += u_exp*fdamp;
                                       double blah = -gamma*R*Math.exp(-gamma*(R-R0));
                                       rdudr += (eks*(c[ind1]*R + 2*c[ind2]*R2 + 3*c[ind3]*R2*R) - beta*R*u_exp)*(fdamp) +
                                                - u_exp*fdamp*fdamp*blah;
                                       r2d2udr2 += (eks*(2*c[ind2]*R2 + 6*c[ind3]*R2*R) - 2*beta*R*eks*(c[ind1]*R + 2*c[ind2]*R2 + 3*c[ind3]*R2*R) + beta*beta*R2*u_exp)*fdamp
                                                - 2*(eks*(c[ind1]*R + 2*c[ind2]*R2 + 3*c[ind3]*R2*R) - beta*R*u_exp)*fdamp*fdamp*blah
                                                + 2*u_exp*fdamp*fdamp*fdamp*blah*blah + u_exp*fdamp*fdamp*blah*gamma*R;
//                                       System.out.println(R/bohrConv+" "+u+" "+rdudr/R*bohrConv+" "+r2d2udr2/R2*bohrConv*bohrConv);
                                   }
                                   else {
                                       u += u_exp;
                                       rdudr += eks*(c[ind1]*R + 2*c[ind2]*R2 + 3*c[ind3]*R2*R) - beta*R*u_exp;
                                       r2d2udr2 += eks*(2*c[ind2]*R2 + 6*c[ind3]*R2*R) - 2*beta*R*eks*(c[ind1]*R + 2*c[ind2]*R2 + 3*c[ind3]*R2*R) + beta*beta*R2*u_exp;
//                                       System.out.println(R/bohrConv+" "+u+" "+rdudr/R*bohrConv+" "+r2d2udr2/R2*bohrConv*bohrConv);
                                   }
                                   if (Double.isNaN(u)) {
                                       throw new RuntimeException("oops");
                                   }
                                }
                
                                if (nsA < 5 && nsB < 5) { // elst
                                   double qA = params[ind_charge[nsA]];
                                   double qB = params[ind_charge[nsB]];
                                   double d1 = params[ind_d1[nsA][nsB]];
                                   double[] f = ddamp(1,d1,R);
                                   double br = d1*R;
                                   double expbr = Math.exp(-br);
                                   u += f[3]* qA*qB/R;
                                   rdudr += -(-expbr*f[4] + 1*f[3])*qA*qB/R;
                                   r2d2udr2 += -(expbr*br*f[4] -expbr*f[5] + 1*(-f[3] + expbr*f[4]) + -1*(-expbr*f[4] + 1*f[3]))*qA*qB/R;
//                                   if (nsA+nsB==0) System.out.println(R/bohrConv+" "+Hartree.UNIT.toSim(u)+" "+Hartree.UNIT.toSim(rdudr)/R*bohrConv+" "+Hartree.UNIT.toSim(r2d2udr2)/R2*bohrConv*bohrConv);
//                                   if (nsA+nsB==0) System.out.println(R+" "+u+" "+rdudr+" "+r2d2udr2);
                                   
//                                   double rdu6dr = (-expbr*br*sum + expbr*dsum + 6*(1-expbr*sum))*C6[ii][jj]/rij6;
//                                   double r2du26dr2 = (expbr*br*br*sum-expbr*br*dsum -br*expbr*dsum+expbr*d2sum + 6*(-1 + br*expbr*sum-expbr*dsum+expbr*sum) + -6*(-expbr*br*sum + expbr*dsum + 6*(1-expbr*sum)))*C6[ii][jj]/rij6;

                                   if (Double.isNaN(u)) {
                                       throw new RuntimeException("oops");
                                   }
                                }

                                
                                if (nsA < 3 && nsB < 3) {    // ind-disp
                                    double d6 = params[ind_d6[nsA][nsB]];
                                    double d8 = params[ind_d8[nsA][nsB]];
                                    double d10 = params[ind_d10[nsA][nsB]];
                                    double C6 = params[ind_C6[nsA][nsB]];
                                    double C8 = params[ind_C8[nsA][nsB]];
                                    double C10 = params[ind_C10[nsA][nsB]];
                                    double R6 = R2*R2*R2;
                                    double R8 = R6*R2;
                                    double R10 = R8*R2;

                                    double[] f = ddamp(6,d6,R);
                                    // f3 = 1-expbr*sum
                                    // f4 = f0*br - f1
                                    // f5 = f1*br - f2
                                    u += -f[3]*C6/R6;
                                    double br = d6*R;
                                    double expbr = Math.exp(-br);
                                    rdudr += (-expbr*f[4] + 6*f[3])*C6/R6;
                                    r2d2udr2 += (expbr*br*f[4] -expbr*f[5] + 6*(-f[3] +expbr*f[4]) + -6*(-expbr*f[4] + 6*f[3]))*C6/R6;

                                    f = ddamp(8,d8,R);
                                    br = d8*R;
                                    expbr = Math.exp(-br);
                                    u += -f[3]*C8/R8;
                                    rdudr += (-expbr*f[4] + 8*f[3])*C8/R8;
                                    r2d2udr2 += (expbr*br*f[4] -expbr*f[5] + 8*(-f[3] + expbr*f[4]) + -8*(-expbr*f[4] + 8*f[3]))*C8/R8;

                                    f = ddamp(10,d10,R);
                                    u += -f[3]*C10/R10;
                                    br = d10*R;
                                    expbr = Math.exp(-br);
//                                    System.out.println(d10+" "+R+" "+expbr*br*f[0]+" "+expbr*f[1]+" "+10*f[3]+" "+(-expbr*br*f[0] + expbr*f[1] + 10*f[3]));
                                    rdudr += (-expbr*f[4] + 10*f[3])*C10/R10;
                                    r2d2udr2 += (expbr*br*f[4] -expbr*f[5] + 10*(-f[3] + expbr*f[4]) + -10*(-expbr*f[4] + 10*f[3]))*C10/R10;
//                                    System.out.println(R/bohrConv+" "+Hartree.UNIT.toSim(u)+" "+Hartree.UNIT.toSim(rdudr)/R*bohrConv+" "+Hartree.UNIT.toSim(r2d2udr2)/R2*bohrConv*bohrConv);
                                    if (Double.isNaN(u)) {
                                        throw new RuntimeException("oops");
                                    }
                                }
                
                                u0 += u;
                                if (Double.isNaN(u0)) {
                                    throw new RuntimeException("oops");
                                }
//                                System.out.println("u0sc "+u0);

                                // molecule 0
                                drijRot.E(drij);
                                rot[iA].transform(drijRot);
                                ijTensor.Ev1v2(drijRot, drijRot);
                                ijTensor.TE((rdudr - r2d2udr2)/(R2*R2));
                                ijTensor.PEa1Tt1(-rdudr/R2, identity);

                                tt0Tensor.ME(ijTensor);

                                rTensor0.transpose();
                                ijRTensor.E(rTensor0);
                                ijRTensor.TE(ijTensor);
                                rTensor0.transpose();
                                ijRTensor.TE(rTensor0);
                                rr0Tensor.ME(ijRTensor);
                                
                                drijRot.TE(rdudr/R2);
                                gi[0][nsA].ME(drijRot);
                                if (gi[0][nsB].isNaN()) {
                                    throw new RuntimeException("oops");
                                }


                                // molecule 1
                                drijRot.E(drij);
                                rot[iB].transform(drijRot);
                                ijTensor.Ev1v2(drijRot, drijRot);
//                                System.out.println("r2 "+rij2+" "+ijTensor.component(0,0));
                                ijTensor.TE((rdudr - r2d2udr2)/(R2*R2));
                                ijTensor.PEa1Tt1(-rdudr/R2, identity);

                                // we only need tt for 0, both have the same contribution
                                tt1Tensor.ME(ijTensor);
//                                System.out.println("d2 "+r2d2udr2/rij2+" "+ijTensor.component(0,0)+" "+tt1Tensor.component(0,0));

                                rTensor1.transpose();
                                ijRTensor.E(rTensor1);
                                ijRTensor.TE(ijTensor);
                                rTensor1.transpose();
                                ijRTensor.TE(rTensor1);
                                rr1Tensor.ME(ijRTensor);
                                
                                drijRot.TE(rdudr/R2);
                                gi[1][nsB].PE(drijRot);
                                if (gi[1][nsB].isNaN()) {
                                    throw new RuntimeException("oops");
                                }

                            }
                        }
                        for (int i=0; i<sites.length; i++) {
                            rr0Tensor.PEv1v2(sites[i], gi[0][i]);
                            // we really just want to modify the diagonal, but we don't care
                            // abuot the off-diagonal
                            rr0Tensor.PE(-sites[i].dot(gi[0][i]));

                            rr1Tensor.PEv1v2(sites[i], gi[1][i]);
                            rr1Tensor.PE(-sites[i].dot(gi[1][i]));
                        }
                        for (int i=0; i<3; i++){
                            d2tot[iA][i] = tt0Tensor.component(i,i);
                            d2tot[iB][i] = tt1Tensor.component(i,i);
                            d2tsum += tt0Tensor.component(i,i)/mass;
                        }
                        for (int i=0; i<3; i++){
                            d2tot[iA][3+i] = rr0Tensor.component(i,i);
                            d2tot[iB][3+i] = rr1Tensor.component(i,i);
                            d2rsum += (rr0Tensor.component(i,i) + rr1Tensor.component(i,i))/(2*moment.getX(i));
                        }
                        for (int j=0; j<3; j++) {
                            d2tot[iA][j] = Hartree.UNIT.toSim(d2tot[iA][j]*bohrConv*bohrConv);
                            d2tot[iA][3+j] = Hartree.UNIT.toSim(d2tot[iA][3+j]);
                            d2tot[iB][j] = Hartree.UNIT.toSim(d2tot[iB][j]*bohrConv*bohrConv);
                            d2tot[iB][3+j] = Hartree.UNIT.toSim(d2tot[iB][3+j]);
                        }
                    }
                }
            }
            if (Hartree.UNIT.toSim(u0) > 10000) {
                return Double.POSITIVE_INFINITY;
            }
            double uInd = 0;
            if (component != Component.TWO_BODY && component != Component.THREE_BODY) {
                uInd = indN_iter();
            }
            double u3 = 0;
            if (component != Component.TWO_BODY && component != Component.INDUCTION) {
                for (int i = 0; i<atoms.size()-2; i++) {
                    com3[0] = com0[i];
                    sitePos3[0] = sitePos[i];
                    for (int j = i+1; j<atoms.size()-1; j++) {
                        com3[1] = com0[j];
                        sitePos3[1] = sitePos[j];
                        for (int k = j+1; k<atoms.size(); k++) {
                            com3[2] = com0[k];
                            sitePos3[2] = sitePos[k];
                            u3 += fit3b();
                        }
                    }
                }
            }
            // semiclassical correction only accounts for u0
            if (Math.random() < 0.001 && false) {
                System.out.println(String.format("% 10.4e  % 10.4e  % 10.4e  % 10.4e", Hartree.UNIT.toSim(u0), Hartree.UNIT.toSim(uInd), Hartree.UNIT.toSim(u3), Hartree.UNIT.toSim(fac*(d2tsum*bohrConv*bohrConv + d2rsum))));
            }
            return Hartree.UNIT.toSim(u0 + uInd + u3 + fac*(d2tsum + d2rsum)*bohrConv*bohrConv);
        }

        protected double[] ddamp(int n, double beta, double r) {
            double br=beta*r;
            drvDamp[0] = 1;
            drvDamp[1] = drvDamp[2] = 0;
            drvDamp[3] = 0;
            
            if(br==0) {
                return drvDamp;
            }
            double sum = 1;
            double dsum = 0;
            double d2sum = 0;
            double term = 1;
            double dterm = 1;
            double d2term = 0;
            for (int i=1; i<=n; i++) {
                term *= br/i;
                if (i==1) {
                    dterm = br;
                }
                else {
                    dterm *= br/(i-1);
                }
                if (i==2) {
                    d2term = br*br;
                }
                else if (i>2) {
                    d2term *= br/(i-2);
                }
                sum += term;
                dsum += dterm;
                d2sum += d2term;
            }

            drvDamp[0]=sum;
            drvDamp[1]=dsum;
            drvDamp[2]=d2sum;
            drvDamp[3]=1.0 - Math.exp(-br)*sum;
            drvDamp[4] = term*br;  // f0*br - f1
            drvDamp[5] = dterm*br;  // f1*br - f2
            // in case of d --> 0 use
            // d=1.0d0 - dexp(-br)*sum = sum_m=ncn+1^\infty br^m/m!
            if(Math.abs(drvDamp[3])<1.0e-8) {
                drvDamp[3]=0.0;
                for (int i=n+1; i<=1000; i++) {
                    term=term*br/i;
                    drvDamp[3]+=term;
                    if(term/drvDamp[3] < 1.0e-8) break;
                }
                if (term/drvDamp[3] > 1e-8) throw new RuntimeException("No convergence in damp"+" "+r);
                drvDamp[3]*=Math.exp(-br);
            }
            //     write(6,'(i4,2f10.5,e20.10)') n,beta,r,d
            return drvDamp;
        }

    }
    
    public static void main1(String[] args) {
        double bohrConv = BohrRadius.UNIT.fromSim(1);
        Space space = Space3D.getInstance();
        Simulation sim = new Simulation(space);
        SpeciesGeneral species = SpeciesSpheresRotating.create(space, new ElementSimple("H2O", Oxygen.INSTANCE.getMass()+2*Hydrogen.INSTANCE.getMass()), false, false);
        sim.addSpecies(species);
        Box box = new Box(space);
        sim.addBox(box);
        box.setNMolecules(species, 2);
        box.getBoundary().setBoxSize(Vector.of(new double[]{100, 100, 100}));
        IAtomList pair = box.getLeafList();
        IAtomOriented atom1 = (IAtomOriented)pair.get(0);
        IAtomOriented atom2 = (IAtomOriented)pair.get(1);
        atom2.getPosition().setX(0, 10/bohrConv);
//        ((IAtomOriented)pair.getAtom(0)).getOrientation().setDirection(space.makeVector(new double[]{Math.cos(22.5/180.0*Math.PI), Math.sin(22.5/180.0*Math.PI),0}));
//        ((OrientationFull3D)atom1.getOrientation()).setDirections(space.makeVector(new double[]{0,1,0}),
//                                                                  space.makeVector(new double[]{-1,0,0}));
        P2WaterSzalewicz p2 = new P2WaterSzalewicz(space, 2);
        P2WaterSzalewicz p3 = new P2WaterSzalewicz(space, 3);
        p3.setComponent(Component.ALL);

        System.out.println("or0: "+((IAtomOriented)pair.get(0)).getOrientation().getDirection()+" "+((OrientationFull3D)((IAtomOriented)pair.get(0)).getOrientation()).getSecondaryDirection());
        System.out.println("or1: "+atom1.getOrientation().getDirection()+" "+((OrientationFull3D)atom1.getOrientation()).getSecondaryDirection());
        Vector d1 = Vector.of(new double[]{2.9073039245633998, 0.0000000000000000, 0.0000000000000000});
        Vector d2 = Vector.of(new double[]{0.0000000000000000, 0.41344259999999999, 0.0000000000000000});
        d1.normalize();
        d2.normalize();
        d1.E(new double[]{1.1732683191861213, 2.4157477549321920, -1.1135620079348942});
        d2.E(new double[]{-0.32459448670357105, 0.21889876419541379, 0.13287789029829400});
        d1.normalize();
        d2.normalize();
        ((OrientationFull3D)atom1.getOrientation()).setDirections(d1, d2);
        d1.E(new double[]{-1.7732319827848091, 2.1369384176381891, -0.86113799372272015});
        d2.E(new double[]{-0.23318742162778205, -5.7913734915365112E-002, 0.33645862925105652});
        d1.normalize();
        d2.normalize();
        ((OrientationFull3D)atom2.getOrientation()).setDirections(d1, d2);

        atom1.getPosition().setX(0, BohrRadius.UNIT.toSim(5));
        atom2.getPosition().setX(0, BohrRadius.UNIT.toSim(-1));
        atom2.getPosition().setX(1, BohrRadius.UNIT.toSim(4));
        System.out.print(String.format("%20.15e\n", Hartree.UNIT.fromSim(p2.energy(pair))));

//        for (int i=20; i<=20; i++) {
//            atom1.getPosition().setX(0, i*0.25);
//            System.out.print(String.format("%5.2f  %20.15e\n", i*0.25, Hartree.UNIT.fromSim(p3.energy(pair))));
//        }
    }
    
    public static void main3(String[] args) {
        Space space = Space3D.getInstance();
        Simulation sim = new Simulation(space);
        SpeciesGeneral species = SpeciesSpheresRotating.create(space, new ElementSimple("H2O", Oxygen.INSTANCE.getMass()+2*Hydrogen.INSTANCE.getMass()), false, false);
        sim.addSpecies(species);
        Box box = new Box(space);
        sim.addBox(box);
        box.setNMolecules(species, 3);
        box.getBoundary().setBoxSize(Vector.of(new double[]{1000, 1000, 1000}));
        IAtomList triplet = box.getLeafList();
        IAtomOriented atom1 = (IAtomOriented)triplet.get(0);
        IAtomOriented atom2 = (IAtomOriented)triplet.get(1);
        IAtomOriented atom3 = (IAtomOriented)triplet.get(2);
        AtomPair pair12 = new AtomPair(atom1, atom2);
        AtomPair pair13 = new AtomPair(atom1, atom3);
        AtomPair pair23 = new AtomPair(atom2, atom3);
        atom2.getPosition().setX(0, 10);
        P2WaterSzalewicz p2 = new P2WaterSzalewicz(space, 2);
        p2.setComponent(Component.NON_PAIR);
        P2WaterSzalewicz p3 = new P2WaterSzalewicz(space, 3);
        p3.setComponent(Component.NON_PAIR);


        atom1.getPosition().setX(0, BohrRadius.UNIT.toSim(-5));
        atom2.getPosition().setX(0, BohrRadius.UNIT.toSim(5));
        atom3.getPosition().setX(1, BohrRadius.UNIT.toSim(50));
//        double u3 = Hartree.UNIT.fromSim(p3.energy(triplet)-(p2.energy(pair12)+p2.energy(pair13)+p2.energy(pair23)));
//        System.out.println("u3 "+BohrRadius.UNIT.toSim(50)+" "+u3);
//        System.exit(1);
        for (int i=0; i<100; i++) {
            double r = 2*Math.pow(1.06, i);
            System.out.print(String.format("%6.3f  ", BohrRadius.UNIT.toSim(r)));
            atom3.getPosition().setX(1, BohrRadius.UNIT.toSim(r));
            double utot = 0;
            for (int j=0; j<2; j++) {
                for (int k=0; k<2; k++) {
                    for (int l=0; l<2; l++) {
                        double una = p3.energy(triplet)-(p2.energy(pair12)+p2.energy(pair13)+p2.energy(pair23));
//                        System.out.print(String.format("%10.4e  ", una));
                        utot += una;
                        atom3.getOrientation().getDirection().TE(-1);
                    }
                    atom2.getOrientation().getDirection().TE(-1);
                }
                atom1.getOrientation().getDirection().TE(-1);
            }
            System.out.print(String.format("%20.15e\n", Kelvin.UNIT.fromSim(utot/8)-0*6.583231966245653e+01));
        }

//        for (int i=20; i<=20; i++) {
//            atom1.getPosition().setX(0, i*0.25);
//            System.out.print(String.format("%5.2f  %20.15e\n", i*0.25, Hartree.UNIT.fromSim(p3.energy(pair))));
//        }
    }

    /*
     * Randomly moves molcules all over, computing and checking 2nd derivative
     */
    public static void main2(String[] args) {
        Space space = Space3D.getInstance();
        double temperature = Kelvin.UNIT.toSim(200);
        Simulation sim = new Simulation(space);
        SpeciesGeneral speciesH2O = SpeciesSpheresRotating.create(space, new ElementSimple("H2O", Oxygen.INSTANCE.getMass()+2*Hydrogen.INSTANCE.getMass()), false, false);
        sim.addSpecies(speciesH2O);
        Box box = new Box(space);
        sim.addBox(box);
        box.setNMolecules(speciesH2O, 2);
        box.getBoundary().setBoxSize(Vector.of(new double[]{100, 100, 100}));
        IAtomList pair = box.getLeafList();
        IAtomOriented atom0 = (IAtomOriented)pair.get(0);
        IAtomOriented atom1 = (IAtomOriented)pair.get(1);
//        ((IAtomOriented)pair.getAtom(0)).getOrientation().setDirection(space.makeVector(new double[]{Math.cos(22.5/180.0*Math.PI), Math.sin(22.5/180.0*Math.PI),0}));
        Vector o1 = Vector.of(new double[]{-1, 0, 0});
        atom0.getOrientation().setDirection(o1);
        atom1.getOrientation().setDirection(o1);
        P2WaterSzalewicz p2 = new P2WaterSzalewicz(space, 2);
        p2.setComponent(Component.TWO_BODY);
        P2H2OSC p2SC = p2.makeSemiclassical(temperature);
//        System.out.println("or: "+atom0.getOrientation().getDirection()+" "+atom1.getOrientation().getDirection());
        double lu = 0, lg = 0;
        double dx = 0.0001;
        Vector x = null;
        Vector y = null;
        Vector z = Vector.of(new double[]{0, 0, 1});
        atom1.getPosition().setX(0, 5);
//        ((OrientationFull3D)atom1.getOrientation()).rotateBy(-Math.atan2(p2.sitesHH*0.5,p2.sitesOH-cmx), z);
//        ((OrientationFull3D)atom1.getOrientation()).rotateBy(Math.PI/2, y);
        Vector vdx = space.makeVector();
//        ((OrientationFull3D)atom1.getOrientation()).rotateBy(0.28, z);

        RandomMersenneTwister random = new RandomMersenneTwister(RandomNumberGeneratorUnix.getRandSeedArray());
        random = new RandomMersenneTwister(5);
        Vector[] xyzAxes = new Vector[]{x,y,z};
        double[] u = new double[3];
        for (int j=0; j<100; j++) {
            int imol = random.nextInt(2);
//            imol = 1;
            IAtomOriented iAtom = imol == 0 ? atom0 : atom1;
            x = iAtom.getOrientation().getDirection();
            xyzAxes[0] = x;
            y = ((OrientationFull3D)iAtom.getOrientation()).getSecondaryDirection();
            xyzAxes[1] = y;
            z.E(x);
            z.XE(y);
//            System.out.println(x+" "+y+" "+z);
            boolean rot = random.nextInt(2) == 0;
//            rot = true;
            double d2 = 0;
            int xyz = random.nextInt(3);
//            xyz = 2;
            vdx.E(xyzAxes[xyz]);
            if (random.nextInt(2)==0) {
                if (rot) {
                    ((IOrientation3D)iAtom.getOrientation()).rotateBy(0.5, vdx);
                }
                else {
                    iAtom.getPosition().PEa1Tv1(0.5, vdx);
                    atom0.getPosition().TE(0.8);
                    atom1.getPosition().TE(0.8);
                }
                continue;
            }
            if (rot) {
//                System.out.println("vdx "+vdx);
//                if (imol==1 && xyz==0) dx *= 0.1;
                for (int i=0; i<3; i++) {
                    ((IOrientation3D)iAtom.getOrientation()).rotateBy(dx, vdx);
                    u[i] = p2.energy(pair);
                    
//                    if (imol==1 && xyz==0) System.out.println(u[i]);
                    if (i==1) {
                        p2SC.energy(pair);
                        d2 = p2SC.d2tot[imol][3+xyz];
                    }
                }
            }
            else {
                for (int i=0; i<3; i++) {
                    iAtom.getPosition().PEa1Tv1(dx, vdx);
                    u[i] = p2.energy(pair);
                    if (i==1) {
                        p2SC.energy(pair);
                        d2 = p2SC.d2tot[imol][xyz];
                    }
                    else {
                        p2SC.energy(pair);
                    }
                }
            }
            double d2fd = (u[0] - 2*u[1] + u[2])/(dx*dx);
//            if (d2==0 && d2fd==0) continue;
            double check = Math.abs(d2)+Math.abs(d2fd)==0 ? 0 : (d2fd-d2)/(0.5*(Math.abs(d2)+Math.abs(d2fd)));
            System.out.print(String.format("%d %d %d %d %+10.4e %+10.4e %10.4e\n", j, imol, rot?1:0, xyz, d2, d2fd, check));
            if (Math.abs(check) > 0.01) {
                throw new RuntimeException("oops");
            }
        }
    }
    
    public static void main(String[] args) {
        double s = 0;
        double bohrConv = BohrRadius.UNIT.toSim(1);
        for (int i=0; i<P2WaterSzalewicz.pol.length; i++) {
            s += P2WaterSzalewicz.pol[i];
        }
        double[] q = P2WaterSzalewicz.getQ();
        Vector[] sp = P2WaterSzalewicz.getSites(Space3D.getInstance());
        Vector d = Space3D.getInstance().makeVector();
        for (int i=0; i<q.length; i++) {
            d.PEa1Tv1(q[i], sp[i]);
        }
        System.out.println("total polarizability "+s*bohrConv*bohrConv*bohrConv);
        System.out.println("total dipole "+Debye.UNIT.fromSim(d.getX(2)));
        System.exit(1);
        Space space = Space3D.getInstance();
        double temperature = Kelvin.UNIT.toSim(200);
        Simulation sim = new Simulation(space);
        SpeciesGeneral speciesH2O = SpeciesSpheresRotating.create(space, new ElementSimple("H2O", Oxygen.INSTANCE.getMass()+2*Hydrogen.INSTANCE.getMass()), false, false);
        sim.addSpecies(speciesH2O);
        Box box = new Box(space);
        sim.addBox(box);
        box.setNMolecules(speciesH2O, 2);
        box.getBoundary().setBoxSize(Vector.of(new double[]{100, 100, 100}));
        IAtomList pair = box.getLeafList();
        IAtomOriented atom0 = (IAtomOriented)pair.get(0);
        IAtomOriented atom1 = (IAtomOriented)pair.get(1);
        Vector p1 = atom1.getPosition();
        IOrientation or0 = atom0.getOrientation();
        OrientationFull3D or1 = (OrientationFull3D)atom1.getOrientation();
        P2WaterSzalewicz p2 = new P2WaterSzalewicz(space, 2);
        System.exit(1);
        P2H2OSC p2SC = p2.makeSemiclassical(temperature);
        P2H2OSC p2CSC = p2.makeSemiclassical(Double.POSITIVE_INFINITY);
//        ((OrientationFull3D)atom1.getOrientation()).setDirections(o1, o2);
        System.out.println("H2O 0: "+or0.getDirection());

        p1.setX(0, BohrRadius.UNIT.toSim(9));
        double uc = p2.energy(pair);
        double usc = p2SC.energy(pair);
        double ucsc = p2CSC.energy(pair);
        System.out.println("rO:  9,0,0");
        System.out.println("O-H: "+or1.getDirection());
        System.out.println("H-H: "+or1.getSecondaryDirection());
        System.out.println(String.format("uc:     %+22.15e", uc));
        System.out.println(String.format("uFH:    %+22.15e", usc));
        System.out.println(String.format("uFH-uc: %+22.15e", usc-uc));
        System.out.println(String.format("uFHc:   %+22.15e", ucsc));

        System.out.println();
        p1.setX(0, BohrRadius.UNIT.toSim(6));
        p1.setX(1, BohrRadius.UNIT.toSim(6));
        p1.setX(2, BohrRadius.UNIT.toSim(0));
        or1.setDirections(Vector.of(new double[]{0, 0, 1}),Vector.of(new double[]{1, 0, 0}));
        uc = p2.energy(pair);
        usc = p2SC.energy(pair);
        ucsc = p2CSC.energy(pair);
        System.out.println("rO:  6,6,0");
        System.out.println("O-H: "+or1.getDirection());
        System.out.println("H-H: "+or1.getSecondaryDirection());
        System.out.println(String.format("uc:     %+22.15e", uc));
        System.out.println(String.format("uFH:    %+22.15e", usc));
        System.out.println(String.format("uFH-uc: %+22.15e", usc-uc));
        System.out.println(String.format("uFHc:   %+22.15e", ucsc));

    }

}
