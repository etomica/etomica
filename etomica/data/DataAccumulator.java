package etomica.data;


/**
 * DataProcessor that accumulates and transforms given data and intermittently transmits
 * processed data to other DataSink(s).  As a DataSink in a data stream, this instance will
 * take data given to it and perform some action using it (for example, accumulating an
 * average or other statistics, updating a histogram).  After a specified number of times,
 * this instance will push the accumulated data to DataSink(s) that have been added to it.
 */

/*
 * History
 * Created on Jul 28, 2004 by kofke
 */

public abstract class DataAccumulator extends DataProcessorForked implements DataSource {

    /**
     * Constructs accumulator with no initial DataSink.
     */
    public DataAccumulator() {
        super();
        setPushInterval(1);
    }
    
	/**
	 * Constructs DataAccumulator with the given DataSink.
	 */
	public DataAccumulator(DataSink dataSink) {
        this();
		setDataSink(dataSink);
	}
    
    /**
     * Defined by subclass to specify what this accumulator does when data is added to it.
     */
    protected abstract void addData(Data data);

    /**
     * Defined by subclass to perform some action that clears accumulated values. 
     */
    public abstract void reset();
    
    /**
     * Returns the Data generated by accumulating the Data previously given to this instance.
     * Part of the DataSource interface.
     */
    public abstract Data getData();

    /**
     * Implementation of DataProcessor interface.
     * Returns getData() every <tt>pushInterval</tt> times it is invoked, otherwise returns null
     * (thereby preventing transmission of data to the next DataSinks).
     * If isActive is false, data is not accumulated and no action is performed.
     */
    public Data processData(Data inputData) {
        if(!active) return null;
        addData(inputData);
        if (--putCount == 0) {
            putCount = pushInterval;
            return getData();
        }
        return null;
    }

	/**
	 * Indicates whether accumulation is being performed in response to interval events.
	 */
	public boolean isActive() {
		return active;
	}
	/**
	 * Sets whether accumulation is to be performed in response to interval events.
	 * Default is true.
	 */
	public final void setActive(boolean active) {
		this.active = active;
	}

    /**
     * Accumulated data are pushed to the data sinks after every pushInterval calls
     * to putData.  This method returns the current value of pushInterval.  Default
     * value is 1, meaning that accumulated Data is pushed every time addData is called.
     */
    public final int getPushInterval() {
        return pushInterval;
    }
    
    /**
     * Accumulated data are pushed to the data sinks after every pushInterval calls
     * to putData.  This method sets the pushInterval, and argument must be greater
     * than zero.  Default value is 1, meaning that every call to addData causes
     * accumulator data to be pushed to its sink.
     * 
     * @throws IllegalArgumentException if argument is less than or equal to zero.
     */
    public final void setPushInterval(int i) {
        if(i > 0) {
            pushInterval = i;
            putCount = pushInterval;
        }
        else throw new IllegalArgumentException("Illegal value of push interval");
    }
    
    /**
     * Overrides the Object class toString method to have it return the output of dataInfo.getLabel()
     */
    public String toString() {
        if(dataInfo == null) {
            return "Accumulator";
        }
        return dataInfo.getLabel() + " accumulator";
    }

    
    /**
	 * Counter that keeps track of the number of interval events received since last call to updateSums
	 */
    protected int putCount;

    /**
     * Accumulated data are pushed to the data sinks after every pushInterval calls
     */
    private int pushInterval;

	/**
	 * Flag specifying whether the manager responds to integrator events
	 */
	protected boolean active = true;
}
